Index: modules/framework/workflow.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import asyncio\r\n\r\nfrom modules.stages import *\r\nfrom modules.actions import *\r\nfrom modules.stages.stage import StageType, StageResult\r\nfrom modules.utils import init_workspace\r\nfrom modules.utils.logger import setup_logger\r\nfrom modules.framework.stage_transition import StageTransition\r\nfrom modules.framework.workflow_context import WorkflowContext\r\n\r\n\r\nclass Workflow:\r\n    STAGE_POOL = {\r\n        StageType.AnalyzeStage: AnalyzeStage(AnalyzeReqs()),\r\n        StageType.DesignStage: DesignStage(DesignFunction()),\r\n        StageType.CodingStage: CodingStage(WriteCode()),\r\n        StageType.RunningStage: RunningStage(RunCode()),\r\n        StageType.FinalStage: FinalStage(),\r\n    }\r\n\r\n    # ACTION_POOL = {\r\n    #     ActionType.WriteCode: WriteCode(),\r\n    #     ActionType.RewriteCode: RewriteCode(),\r\n    #     ActionType.WritePrompt: WritePrompt(),\r\n    #     ActionType.RunCode: RunCode(),\r\n    # }\r\n\r\n    def __init__(self, user_command: str, init_stage: StageType = StageType.AnalyzeStage):\r\n        self.__stage = init_stage\r\n        self._logger = setup_logger(\"Workflow\")\r\n        workflow_context = WorkflowContext()\r\n        workflow_context.user_command.message = user_command\r\n\r\n    async def run(self):\r\n        while self.__stage != StageType.FinalStage:\r\n            stage = self.create_stage(self.__stage)\r\n            stage_result = await stage.run()\r\n\r\n            temp = StageTransition[self.__stage]\r\n            for key in stage_result.keys:\r\n                temp = temp[key]\r\n\r\n            self.__stage = temp\r\n        else:\r\n            self._logger.info(\"=================== END ===================\")\r\n\r\n    @staticmethod\r\n    def create_stage(stage_type: StageType):\r\n        try:\r\n            return Workflow.STAGE_POOL[stage_type]\r\n        except KeyError:\r\n            raise ValueError(f\"Invalid stage type: {stage_type}\")\r\n\r\n    # @staticmethod\r\n    # def create_action(action_type: ActionType):\r\n    #     if action_type == ActionType.WriteCode:\r\n    #         return Workflow.ACTION_POOL[ActionType.WriteCode]\r\n    #     elif action_type == ActionType.RewriteCode:\r\n    #         return Workflow.ACTION_POOL[ActionType.RewriteCode]\r\n    #     elif action_type == ActionType.WritePrompt:\r\n    #         return Workflow.ACTION_POOL[ActionType.WritePrompt]\r\n    #     elif action_type == ActionType.RunCode:\r\n    #         return Workflow.ACTION_POOL[ActionType.RunCode]\r\n    #     else:\r\n    #         raise ValueError(\"Invalid action type\")\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    task_list = [\r\n        \"Gather these robots together at the position of leader robot\",\r\n        \"Gather the robots to point (2,3)\",\r\n        \"Gather the robots along the y=x trajectory\",\r\n        'Move the robots to form a square formation',\r\n        'First, move the robot to form a square formation. Then, move the robots to form a triangle formation.Finally gather these robots together',\r\n        \"Initially, gather all robots at the center of the environment, confirming their arrival before proceeding. Next, arrange the robots into a square formation with each side measuring exactly 1.0 meter, ensuring the formation's precision with right angles and equal sides. Once the square is confirmed, guide the robots to trace a circular path while maintaining the square formation. Constant monitoring is required to preserve the formation's integrity and the path's accuracy throughout the movement.\",\r\n        \"control the robots to flock \"\r\n    ]\r\n    init_workspace()\r\n    workflow = Workflow(task_list[-1])\r\n    asyncio.run(workflow.run())\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/modules/framework/workflow.py b/modules/framework/workflow.py
--- a/modules/framework/workflow.py	
+++ b/modules/framework/workflow.py	
@@ -73,7 +73,8 @@
         'Move the robots to form a square formation',
         'First, move the robot to form a square formation. Then, move the robots to form a triangle formation.Finally gather these robots together',
         "Initially, gather all robots at the center of the environment, confirming their arrival before proceeding. Next, arrange the robots into a square formation with each side measuring exactly 1.0 meter, ensuring the formation's precision with right angles and equal sides. Once the square is confirmed, guide the robots to trace a circular path while maintaining the square formation. Constant monitoring is required to preserve the formation's integrity and the path's accuracy throughout the movement.",
-        "control the robots to flock "
+        "control the robots to flock ",
+        "control the robots to flock, keep safe distance",
     ]
     init_workspace()
     workflow = Workflow(task_list[-1])
Index: modules/env/environment.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import re\nimport sys\nimport os\nimport cv2\nimport numpy as np\nimport rospy\nimport matplotlib.pyplot as plt\nfrom matplotlib.ticker import MultipleLocator\nfrom std_msgs.msg import Float32MultiArray\nfrom std_srvs.srv import SetBool, SetBoolResponse\n\nfrom robot import Robots, Leader\n\n\nclass Env:\n    def __init__(\n            self,\n            size=(10, 10),\n            n_robots=3,\n            dt=0.01,\n            if_leader=False,\n            leader_speed=2.0,\n            render_interval=10,\n\n    ):\n        rospy.init_node('env_node', anonymous=True)\n        self._size = size\n        self._dt = dt\n        self._render_interval = render_interval\n        self._leader_speed = leader_speed\n        self._robots = Robots(n_robots, self._size)\n        if if_leader:\n            self._leader = Leader(initial_position=(0, 0))\n            self._leader_publisher = rospy.Publisher('/leader/position', Float32MultiArray, queue_size=1)\n        else:\n            self._leader = None\n        self._robots_initial_positions = self._robots.positions.copy()\n        self._position_publisher = rospy.Publisher('/robots/position', Float32MultiArray, queue_size=1)\n        self._reset_service = rospy.Service('/reset_environment', SetBool, self.reset_environment_callback)\n        rospy.set_param('robots_num', n_robots)\n        rospy.Subscriber('/robots/velocity', Float32MultiArray, self.velocity_callback, callback_args=self._robots)\n\n        # flag to indicate if the test is running,if running, the robots will save their positions to history\n        self._run_test = False\n        # flag to indicate if the frames should be rendered\n        self._render_frames = False\n        self._fig, self._ax = plt.subplots()\n\n        # counter for total run time\n        self._run_time = 0\n\n    @staticmethod\n    def velocity_callback(data, robots):\n        \"\"\"\n        velocity_callback is a callback function for the velocity topic.\n        \"\"\"\n        print(\"Received velocity\")\n        robots.velocities = np.array(data.data).reshape(-1, 2)\n\n    def reset_environment_callback(self, req):\n        \"\"\"\n        reset_environment_callback is a callback function for the reset_environment service.\n        It resets the environment to its initial state and returns a success message.\n        must be called before and after running the script\n        \"\"\"\n        self.reset()\n        self._render_frames = req.data\n        print(\"set render frames to\", self._render_frames)\n\n        response = SetBoolResponse()\n        response.success = True\n        response.message = \"Environment reset successful!\"\n        return response\n\n    def reset(self):\n        \"\"\"\n        Reset the environment to its initial state.\n        \"\"\"\n        self._run_test = not self._run_test\n        if not self._run_test:\n            self._robots.positions = self._robots_initial_positions.copy()\n            self._robots.velocities = np.zeros_like(self._robots.velocities)\n            self._robots.history = [self._robots.positions.copy()]\n            data_path = rospy.get_param('data_path', '.')\n            generate_video_from_frames(frames_folder=f'{data_path}/frames', video_path=f'{data_path}/video.mp4')\n            print(\"Test stopped! Waiting for new test...\")\n            print(\"Environment reset successful!\")\n        else:\n            print(\"Test started!\")\n\n    def step(self):\n        if self._run_test:\n            if self._leader:\n                self._leader.move(self._leader_speed, self._dt)\n                self._leader_publisher.publish(Float32MultiArray(data=self._leader.position))\n            self._robots.move_robots(self._dt)\n            self._position_publisher.publish(Float32MultiArray(data=self._robots.positions.flatten().tolist()))\n            self._run_time += 1\n            if self._run_time % self._render_interval == 0:\n                self.render()\n        elif plt.get_fignums():\n            plt.close(self._fig)\n\n    def render(self):\n        if not plt.get_fignums():\n            self._fig, self._ax = plt.subplots()\n        self._ax.clear()\n\n        traj_len, robot_num, _ = self._robots.history.shape\n        for i in range(robot_num):\n            show_len = min(60, traj_len)\n            self._ax.plot(self._robots.history[-show_len:, i, 0],\n                          self._robots.history[-show_len:, i, 1],\n                          label=f\"Robot {i} path\")\n            self._ax.plot(self._robots.history[-1, i, 0],\n                          self._robots.history[-1, i, 1],\n                          'o',\n                          label=f\"Robot {i} position\")\n        self._ax.plot(self._leader.position[0], self._leader.position[1],\n                      marker='*', markersize=12, color='r',\n                      linestyle='None', label=\"Leader position\")\n        x_major_locator = MultipleLocator(1)\n        self._ax.xaxis.set_major_locator(x_major_locator)\n        y_major_locator = MultipleLocator(1)\n        self._ax.yaxis.set_major_locator(y_major_locator)\n        self._ax.set_xlim(-self._size[0], self._size[0])\n        self._ax.set_ylim(-self._size[1], self._size[1])\n        if self._render_frames:\n            plt.draw()\n            plt.pause(0.001)  # This is necessary for the plot to update\n        data_path = rospy.get_param('data_path', '.')\n        if data_path == '.':\n            print(\"data_path not set, save frames to current directory\")\n        frame_id = len(self._robots.history)\n        plt.savefig(f'{data_path}/frames/{frame_id}.png')\n\n    def run(self):\n        print(\"Environment started!\")\n        rate = rospy.Rate(1 / self._dt)\n        while not rospy.is_shutdown():\n            self.step()\n            rate.sleep()\n        print(\"Environment stopped!\")\n\n\ndef generate_video_from_frames(frames_folder, video_path, fps=10):\n    frame_files = sorted(os.listdir(frames_folder), key=lambda x: int(re.search(r'\\d+', x).group()))\n    frame_files = [os.path.join(frames_folder, file) for file in frame_files]\n\n    frame = cv2.imread(frame_files[0])\n    height, width, layers = frame.shape\n    fourcc = cv2.VideoWriter_fourcc(*'mp4v')\n\n    video = cv2.VideoWriter(video_path, fourcc, fps, (width, height))\n\n    for frame_file in frame_files:\n        video.write(cv2.imread(frame_file))\n\n    cv2.destroyAllWindows()\n    video.release()\n    print(f\"Video generated: {video_path}\")\n\n\nif __name__ == \"__main__\":\n    env = Env(if_leader=True, n_robots=100, size=(10, 10))\n    env.run()\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/modules/env/environment.py b/modules/env/environment.py
--- a/modules/env/environment.py	
+++ b/modules/env/environment.py	
@@ -162,5 +162,5 @@
 
 
 if __name__ == "__main__":
-    env = Env(if_leader=True, n_robots=100, size=(10, 10))
+    env = Env(if_leader=True, n_robots=10, size=(10, 10))
     env.run()
